来源：
作者：黄轶
链接：https://juejin.cn/post/6922641008106668045



1. 使用Functional components（函数式组件）
原理：
- 与普通组件不同，函数式组件并不会被看作是一个“真正的组件“。 在Vue的Diff算法中的patch过程中，如果遇到了一个节点是组件Vnode，会递归执行自组建的初始化过程；而函数式组件的render生成的是普通的vnode，不会有递归子组件的过程，因此渲染开销低很多。
所以，函数式组件不会有状态，不会有响应式数据，生命周期钩子函数这些东西。这时候，函数式组件可以被认为是普通组件模版中的一部分DOM，通过函数的方式渲染出来，是一种DOM层面的服用。
2. Child Component Splitting
如果组建中有一部分组件，他的内部没有任何响应式数据的变化。所以变化后的组件不会在每次渲染都执行耗时的任务，使得自动执行JS的时间就变少了；
所以可以把这一部分封装成为一个子组件，避免重复渲染。
3. Local Variables
优化前后代码对比
```
<template>
  <div :style="{ opacity: start / 300 }">{{ result }}</div>
</template>

<script>
export default {
  props: ['start'],
  computed: {
    base () {
      return 42
    },
    result () {
      let result = this.start
      for (let i = 0; i < 1000; i++) {
        result += Math.sqrt(Math.cos(Math.sin(this.base))) + this.base * this.base + this.base + this.base * 2 + this.base * 3
      }
      return result
    },
  },
}
</script>
```
优化后
```
<template>
  <div :style="{ opacity: start / 300 }">{{ result }}</div>
</template>

<script>
export default {
  props: ['start'],
  computed: {
    base () {
      return 42
    },
    result ({ base, start }) {
      let result = start
      for (let i = 0; i < 1000; i++) {
        result += Math.sqrt(Math.cos(Math.sin(base))) + base * base + base + base * 2 + base * 3
      }
      return result
    },
  },
}
</script>
```
性能上的差异来自于对于```this.base```的访问，因为```this.base```是一个响应式对象，每次访问都会触发对它的getter，进而会执行依赖收集相关逻辑代码。所以随着访问次数多增多，每个组件触发computed重新计算，每次又回执行依赖手机相关逻辑，所以会导致性能下降。

this.base 执行一次依赖收集就够了，把它的 getter 求值结果返回给局部变量 base，后续再次访问 base 的时候就不会触发 getter，也不会走依赖收集的逻辑了，性能自然就得到了提升。

4. Reuse DOM with v-show
- v-if 指令在编译阶段就会编译成一个三元运算符，条件渲染
- 对于 v-show 渲染的节点，由于新旧 vnode 一致，它们只需要一直 patchVnode 即可，对于 v-show 渲染的节点，由于新旧 vnode 一致，它们只需要一直 patchVnode 即可，
- 因此相比于 v-if 不断删除和创建函数新的 DOM，v-show 仅仅是在更新现有 DOM 的显隐值，所以 v-show 的开销要比 v-if 小的多，当其内部 DOM 结构越复杂，性能的差异就会越大。

- v-show 相比于 v-if 的性能优势是在组件的更新阶段，如果仅仅是在初始化阶段，v-if 性能还要高于 v-show，原因是在于它仅仅会渲染一个分支，而 v-show 把两个分支都渲染了，通过 style.display 来控制对应 DOM 的显隐。
- 在使用 v-show 的时候，所有分支内部的组件都会渲染，对应的生命周期钩子函数都会执行，而使用 v-if 的时候，没有命中的分支内部的组件是不会渲染的，对应的生命周期钩子函数都不会执行。

5. 使用keep-alive组件缓存DOM
优化前：
```
<template>
  <div id="app">
    <router-view/>
  </div>
</template>
```
优化后：
```
<template>
  <div id="app">
    <keep-alive>
      <router-view/>
    </keep-alive>
  </div>
</template>
```
在非优化场景下，我们每次点击按钮切换路由视图，都会重新渲染一次组件，渲染组件就会经过组件初始化，render、patch 等过程，如果组件比较复杂，或者嵌套较深，那么整个渲染耗时就会很长。
而在使用 KeepAlive 后，被 KeepAlive 包裹的组件在经过第一次渲染后，的 vnode 以及 DOM 都会被缓存起来，然后再下一次再次渲染该组件的时候，直接从缓存中拿到对应的 vnode 和 DOM，然后渲染，并不需要再走一次组件初始化，render 和 patch 等一系列流程，减少了 script 的执行时间，性能更好。
但是使用 KeepAlive 组件并非没有成本，因为它会占用更多的内存去做缓存，这是一种典型的空间换时间优化思想的应用。

6. Defrred Features（使用 Deferred 组件延时分批渲染组件）
- ```Defer``` 的主要思想就是把一个组件的一次渲染拆成多次，它内部维护了 ```displayPriority``` 变量，然后在通过 ```requestAnimationFrame``` 在每一帧渲染的时候自增，最多加到 count。然后使用 Defer mixin 的组件内部就可以通过 v-if="defer(xxx)" 的方式来控制在 displayPriority 增加到 xxx 的时候渲染某些区块了。
- 当有渲染耗时的组件，使用 Deferred 做渐进式渲染是不错的注意，它能避免一次 render 由于 JS 执行时间过长导致渲染卡住的现象。

7. Time slicing 时间片切割技术
优化前：
```
fetchItems ({ commit }, { items }) {
  commit('clearItems')
  commit('addItems', items)
}
```
优化后：
```
fetchItems ({ commit }, { items, splitCount }) {
  commit('clearItems')
  const queue = new JobQueue()
  splitArray(items, splitCount).forEach(
    chunk => queue.addJob(done => {
      // 分时间片提交数据
      requestAnimationFrame(() => {
        commit('addItems', chunk)
        done()
      })
    })
  )
  await queue.start()
}
```
原理：
- 优化前由于一次性提交数据过多，JS 一直长时间运行，阻塞 UI 线程
- 优化后，由于拆成多个时间片去提交数据，单次 JS 运行时间变短了
- 这里要注意的一点，虽然我们拆时间片使用了 requestAnimationFrame API，但是使用 requestAnimationFrame 本身是不能保证满帧运行的，requestAnimationFrame 保证的是在浏览器每一次重绘后会执行对应传入的回调函数，想要保证满帧，只能让 JS 在一个 Tick 内的运行时间不超过 17ms。

8. Non-reactive data
使用非响应式数据
而优化后我们把新提交的数据中的对象属性 data 手动变成了 configurable 为 false，这样内部在 walk 时通过 Object.keys(obj) 获取对象属性数组会忽略 data，也就不会为 data 这个属性 defineReactive，由于 data 指向的是一个对象，这样也就会减少递归响应式的逻辑，相当于减少了这部分的性能损耗。数据量越大，这种优化的效果就会更明显。

9. Virtual scrolling
虚拟滚动组件
虚拟滚动的实现方式，是只渲染视口内的 DOM，这样总共渲染的 DOM 数量就很少了，自然性能就会好很多。

10. 为什么Vue不使用ImmutableJS
- Vue是响应式的，使用不可变实体会失去Vue响应式的优势；进而还需要手动实现类似于Reaact的shouldCompoenntUpdate方法来判断自组建是否需要更新；
- immutable 数据类型，只有在函数式编程才用得到；因为在面向对象中，可以通过封装控制对象的变更；你写一个类，只在构造函数中修改属性，就是个天然 immutable 数据结构。
