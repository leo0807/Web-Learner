# 类加载器

## 类加载的过程
- 加载：将字节码文件通过`IO流`读取到`JVM`的方法区，并同时在堆中生成`Class`对像。 
- 验证：校验字节码文件的正确性。
- 准备：为类的静态变量分配内存，并初始化为默认值；对于`final static`修饰的变量，在编译时就已经分配好内存了。 
- 解析：将类中的符号引用转换为直接引用。 
- 初始化：对类的静态变量初始化为指定的值，执行静态代码。
![类的加载过程](https://img-blog.csdnimg.cn/44c528f1b1cf453298208f96075421ed.jpeg#pic_center)

## 类加载器的分类
1. JVM内置的类加载器,有`Bootstrap`加载器、`ExtClassLoader`加载器和`AppClassLoader`加载器三种,分别负责加载不同目录下的`.class`文件;
2. `用户自定义`的类加载器,负责的加载目录自己决定。

### 引导类加载器 `Bootstrap`
- 引导类加载器属于JVM的一部分，由C++代码实现。
- 引导类加载器负责加载`<JAVA_HOME\>\jre\lib`路径下的核心类库，由于安全考虑只加载包名 `java`、`javax`、`sun`开头的类。
### 扩展类加载器`ExtClassLoader`
- 全类名:`sum.misc.Launch$ExtClassLoader`，`Java`语言实现。
- 扩展类加载器的父加载器是`Bootstrap`启动类加载器 (注:不是继承关系)
- 扩展类加载器负责加载`<JAVA_HOME>\jre\lib\ext`目录下的类库。
### 系统类加载器 AppClassLoader
- 全类名: `sun.misc.Launcher$AppClassLoader`
- 系统类加载器的父加载器是`ExtClassLoader`扩展类加载器（注: 不是继承关系）。
- 系统类加载器负责加载`classpath`环境变量所指定的类库，是用户自定义类的默认类加载器。
### 三者之间的关系
- `AppClassLoader`的父加载器是`ExtClassLoader`
- `ExtClassLoader`的父加载器是`Bootstrap`
- `Bootstrap`是根加载器
- 三者之间是没有继承关系的。
- `AppClassLoader`和`ExtClassLoader`都实现了抽象类`ClassLoader`。
- 抽象类`ClassLoader`有一个字段`parent`, `AppClassLoader`和`ExtClassLoader`通过设置该字段引用,指定父加载器。（是组合关系）
- `AppClassLoader`的parent指向`ExtClassLoader`
- `ExtClassLoader`的parent指向`null`,(null的原因是因为Bootstrap是C++实现的,通过代码中逻辑判断来转向Bootstrap)
### 自定义类加载器
自定义类加载器是为了加载在jvm三个加载器负责的目录范围之外的类
```
package com;

import java.io.*;

/**
 * @Date: 2022/5/2 10:09
 * @author: ZHX
 * @Description: 自定义类加载器
 */
public class MyClassLoader extends ClassLoader {

    private String classPath;

    public MyClassLoader(String classPath) {
        this.classPath = classPath;
    }

    //parent: 指定父加载器, AppClassLoader/ExtClassLoader/Bootstrap
    public MyClassLoader(ClassLoader parent, String classPath) {
        super(parent);
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        //要求返回的是你要加载的字节码文件的Class对象.

        //这里都是我们说了算的。
        //步骤：
        //1. 从本地或网络某处读一个输入流到内存中 .
        //2. 将流内容字节数组 封装成Class对象 (直接调ClassLoader的defineClass方法，JVM会帮我们按照.class文件格式创建好的。)

        //1.
        //处理得到完整路径
        String path = this.classPath + name.replace(".", File.separator) + ".class";

        //2.读取到内存
        try (FileInputStream fis = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            byte[] buffer = new byte[1024];
            int len = 0;
            while ((len = fis.read(buffer)) != -1) {
                //用ByteArrayOutputStream暂存一下。
                baos.write(buffer, 0, len);
            }
            byte[] allByte = baos.toByteArray();
            //将字节数组生成Class对象
            return super.defineClass(name, allByte, 0, allByte.length);
        } catch (IOException e) {
            throw new ClassNotFoundException(name + "加载失败");
        }
    }

	//测试下
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        //使用自己的类加载器，加载D:\\ + com.ali.Hello
        MyClassLoader myClassLoader = new MyClassLoader("d:\\");  //
        //加载 全限定名类
        Class<?> clazz = myClassLoader.loadClass("com.ali.Hello");

        clazz.newInstance();

        System.out.println(clazz.getClassLoader()); //out: 使用的类加载器 MyClassLoader@481248
    }
}
```

### 注：谁来准备类加载器呢?
`AppClassLoader`和`ExtClassLoader`是`Launcher`的静态内部类，在程序启动时JVM会创建Launcher对象，Launcher构造器会同时会创建扩展类加载器和应用类加载器。
![类加载器](https://img-blog.csdnimg.cn/bf687fa01aa24a138d973745d27d0f70.png)


## 双亲委派机制
双亲委派机制就是: 每个类加载器都很懒，加载类时都先让父加载器去尝试加载，父加载器加载不了时自己才去加载。
![双亲委派机制](https://img-blog.csdnimg.cn/b641b8ee54194d1a9b630e92287e42fc.png)

E.g例如: 加载自定义类Demo.class的流程
1. 首先使用`AppClassLoader`类加载器尝试加载，AppClassLoader加载器会先检查它的缓存，查看该类是否已经被加载，有则不加载，没有则向上交给ExtClassLoader加载器。
2. `ExtClassLoader`加载器同样会先检查它的缓存，查看该类是否已经被加载，有则不加载，没有则向上交给Bootstrap加载器。
3. `Bootstrap`加载器同样会先检查它的缓存，查看该类是否已经被加载。有则不加载，没有则尝试从它负责的目录中加载，
4. `Bootstrap`加载器加载失败(不在它负责的目录范围)则向下交给ExtClassLoader加载器。
5. `ExtClassLoader`加载器会从它负责的目录中尝试加载，加载失败则向下交给AppClassLoader加载器
6. `AppClassLoader`加载器从它负责的classpath尝试加载，加载完成。
### 优点
- 避免类的重复加载：当父加载器已经加载该类时，就没有必要子加载器再加载一遍，保证被加载类的唯一性。
- 同时`Java`有**沙箱安全机制**：自定义类的包名以`java.`开头被禁止， 防止核心API被篡改，判断逻辑在`defineClass`方法中。
  ```
  ...
  if ((name != null) && name.startsWith("java.)){
    throw new SecurityException("Prohibted package name: " + name.substring(0, name.lastIndexOf('.')));
  }
  ...
  ```

### 打破双亲委派机制
- 双亲委派机制的实现其实就是在`loadClass`方法中实现的。
- 直接调用`findClass`方法就可以跳过双亲委派机制,这样就可以直接加载,而不用向上委托了。
```
public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        //使用上面自定义的类加载器。
        MyClassLoader myClassLoader1 = new MyClassLoader("d:\\");

        //find方法调用，加载 全限定名类
        Class<?> clazz1 = myClassLoader1.findClass("com.ali.Hello");
        
		System.out.println(clazz1.hashCode()); //out: 26508395

        System.out.println(clazz1.getClassLoader()); //out: 使用的类加载器 MyClassLoader@481248
}
//如果要想一个类加载两次，就需要创建两个类加载器。（因为判断缓存中该字节码文件是否已经已经被加载是在defineClass方法中,而该方法为final我们没法改写.）
public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
    //使用上面自定义的类加载器。
    MyClassLoader myClassLoader1 = new MyClassLoader("d:\\");
    MyClassLoader myClassLoader2 = new MyClassLoader("d:\\");

    //加载 全限定名类
    Class<?> clazz1 = myClassLoader1.findClass("com.ali.Hello");
    Class<?> clazz2 = myClassLoader2.findClass("com.ali.Hello");

    System.out.println(clazz1.hashCode());//out: 22913620
    System.out.println(clazz2.hashCode());//out: 29768086

    System.out.println(clazz1.getClassLoader()); //out: 使用的类加载器 MyClassLoader@481248
    System.out.println(clazz2.getClassLoader()); //out: 使用的类加载器 MyClassLoader@1947c6b
}
```
## ClassLoader抽象类
- 所有的类加载器`(除了Bootstrap)`都要继承`ClassLoader`抽象类。
方法名	作用
public Class<?> loadClass(String name)	双亲委派机制的实现
protected Class<?> findClass(String name)	读取字节码文件到内存并调用defindClass方法生成Class对象
protected final Class<?> defineClass(String name, byte[] b, int off, int len)	先判断是否加载过，然后将字节数组解析成Class对象
protected final void resolveClass(Class<?> c)	连接指定的类
- `loadClass()`方法源码
```
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
	synchronized (getClassLoadingLock(name)) {
	    // First, check if the class has already been loaded
		// 检查类是否已经被加载了
	    Class<?> c = findLoadedClass(name);
	    if (c == null) { //没有
	        long t0 = System.nanoTime();
	        try {
	        	//双亲委派机制加载
	            if (parent != null) {
	                c = parent.loadClass(name, false);
	            } else {
	                c = findBootstrapClassOrNull(name);
	            }
	        } catch (ClassNotFoundException e) {
	            // ClassNotFoundException thrown if class not found
	            // from the non-null parent class loader
	        }
	
	        if (c == null) {
	            // If still not found, then invoke findClass in order
	            // to find the class.
	            long t1 = System.nanoTime();
	            //真正将字节码文件加载到内存。
	            c = findClass(name);
	
	            // this is the defining class loader; record the stats
	            sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
	            sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
	            sun.misc.PerfCounter.getFindClasses().increment();
	        }
	    }
	    if (resolve) {
	        resolveClass(c);
	    }
	    return c;
	}
}
```

## 参考
- [Java - 类加载器](https://blog.csdn.net/ZHHX666/article/details/124484199)
- []
