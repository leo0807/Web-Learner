# Java GC

## GC 分类
JVM中的Garbage Collection，简称GC，它会不定时去堆内存中清理不可达（没有被引用）对象。

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指`新生代`。因此GC按照回收的区域又分了两种类型，一种是普通GC（`minor GC`），一种是全局GC（`major GC or Full GC`），
- 新生代GC（minor GC）：只针对新生代区域的GC。
- 老年代GC（major GC or Full GC）：针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC。
- `Minor GC`触发机制：当`年轻代`满时就会触发Minor GC，这里的年轻代满指的是`Eden区`满，`Survivor`满不会引发GC。
- `Full GC`触发机制：当`年老代`满时会引发Full GC，Full GC将会同时回收年轻代、年老代，当`永久代`满时也会引发Full GC，会导致`Class`、`Method`元信息的卸载。
GC工作特点：理论上GC过程中会频繁收集Young区，很少收集Old区，基本不动Perm区（元空间/方法区）。
### GC方法
- 标记不可达对象的引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减1.任何时刻计数器值为0的对象就是不可能再被使用的。引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到循环指向的存在。主流的Java虚拟机里面都没有选用引用计数算法来管理内存。
- 标记不可达对象的可达性分析（GC Roots算法）：根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
### 垃圾回收的三种方式： 
- 清除：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。清除这种回收方式的原理及其简单，但是有两个缺点。一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。
- 压缩：把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。
- 复制：把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。复制必交换，谁空谁为to。
- 总结：回收死亡对象的内存共有三种方式，分别会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。
### 垃圾回收四大算法：
1. 标记复制(Mark-Copying)算法：
  - 当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。当 Eden 区的空间耗尽了， Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。
2. 新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。
  - Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。
- 万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间。
- 因此Minor GC使用的则是标记-复制算法。将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。

3. 标记清除(Mark-Sweep)算法：                
- 老年代一般是由标记清除或者是标记清除与标记整理的混合实现。标记清除算法一般应用于老年代,因为老年代的对象生命周期比较长。该算法先对所有可访问的对象，做个标记再遍历堆，把未被标记的对象回收（标记活的）。                
- 缺点：回收时，应用需要挂起，也就是stop the world，导致用户体验极差。由于需要遍历全堆对象，效率比较低（递归与全堆对象遍历）。造成内存碎片化。
4. 标记压缩(Mark--Compact)算法：
- 标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化，也消除了复制算法当中，内存减半的高额代价。但效率低，压缩阶段，由于移动了可用对象，需要去更新引用。
5. 标记清除压缩(Mark-Sweep-Compact)算法：
- 标记清除压缩(Mark-Sweep-Compact)算法是标记清除算法和标记压缩算法的结合算法。其原理和标记清除算法一致，只不过会在多次GC后，进行一次Compact操作！
## References
- [JavaEE核心【JVM 的作用、类加载器、JVM内存模型、GC回收机制】](https://blog.csdn.net/weixin_43923463/article/details/122797596)
