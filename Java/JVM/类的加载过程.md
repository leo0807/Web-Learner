# 类的加载过程
<hr />

## 类的五个过程
- 加载
- 验证
- 准备
- 解析
- 初始化
### 类的加载过程
![类的加载过程](https://img-blog.csdnimg.cn/img_convert/b2753b8c78fcded07a9d3b355533bb52.png)
### 类的生命周期
![类的生命周](https://pic1.zhimg.com/80/v2-f3947f904bafb2fc76669dbe7cd6113c_1440w.webp)

### 需要初始化的情况
《Java虚拟机规范》 严格规定了有且只有六种情况必须立即对类进行`“初始化”`：
1. 遇到`new`、`getstatic`、`putstatic`或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
2. 使用`java.lang.reflect`包的方法对类型进行`反射调用`的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其`父类`还没有进行过初始化，则需要先触发其`父类`的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用`JDK 7`新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
这六种场景中的行为称为对一个类型进行主动引用。

接下来我们来详细学习Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化。

### 加载 Loading
所谓`加载`，简而言之就是将 `Java` 类的字节码文件加载到机器内存中，（一个Java文件从编码完成到最终执行，一般主要包括两个过程：编译和运行，其中编译就是把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件，然后运行则是把编译声称的.class文件交给Java虚拟机(JVM)执行。而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。）并在内存中构建出 Java 类的原型——类模板对象。所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用
![Loading](https://pic1.zhimg.com/80/v2-c5257bba5081a767e610b04c70bacdb4_1440w.webp)
## 链接 Linking
### 验证 Verification
- 验证是连接阶段的第一步，这一阶段的目的是确保`Class`文件的**字节流**中包含的信息符合`《Java虚拟机规范》`的全部约束要求。
- 验证阶段大致上会完成下面四个阶段的检验动作：`文件格式验证`、`元数据验证`、`字节码验证`和`符号引用验证`。
![Verification](https://pic4.zhimg.com/80/v2-ba9085befbef4b724d7dd89af08a7d4b_1440w.webp)
- 文件格式验证
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。需要验证魔数、版本号、常量池常量类型是否支持、指向常量的索引值等等。
- 元数据验证
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，包括类是否有父类、父类是否继承了final修饰的类、非抽象类是否实现了父类定义的方法、类是否与父类有矛盾等等。
- 字节码验证
第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证
最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。

符号引用验证主要验证类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

### 准备 Preparation
- 准备阶段是给静态变量**分配内存**并**设置类变量初始值的阶段**。
- 在`JDK 7`及之前，这些变量的内存在方法区（永久代）中分配，在JDK 8及之后，静态变量则会随着Class对象一起存放在Java堆中。
![Preparation](https://pic2.zhimg.com/80/v2-749f3098bb203c518416eed35d65acd9_1440w.webp)

### 解析 Resolution
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。
- 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
![Resolution](https://pic1.zhimg.com/80/v2-d8242b078669fc649dce8698d953a338_1440w.webp)

### 初始化 Initialization
类的初始化阶段是类加载过程的最后一个步骤，在这个阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。
- 准备阶段，变量被赋的是系统要求的零值，在初始化阶段，赋的是代码里编写的值。
- 初始化即调用`< cinit >()V`方法，虚拟机会保证这个类的`构造方法`的线程安全

#### 会导致`类初始化`的情况
- `main`方法所在的类，总会被首先初始化
- 首次访问这个类的`静态变量`或`静态方法`时
- 子类初始化，如果`父类`还未初始化，会引发
- 子类访问父类的`静态变量`，只会触发父类的初始化
- `Class.forName`
- `new` 会导致初始化
#### 不会导致 类初始化 的情况
- 访问类的 `static final` 静态变量（基本类型和字符型）不会触发初始化
- 类对象`.class`不会触发初始化
- 创建该类的数组不会触发初始化
- 类加载的`loadClass`方法
- `Class.forName`的参数`2`为`false`时
 
![Initialization](https://pic2.zhimg.com/80/v2-f367e5e6eb20ee9541a31b0ef324ef6d_1440w.webp)
## 参考
- [类加载的五个过程：加载、验证、准备、解析、初始化](https://blog.csdn.net/Strange_boy/article/details/125717606?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168238756316800197085188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168238756316800197085188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125717606-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187)
- [【JVM进阶之路】之：类加载过程](https://zhuanlan.zhihu.com/p/375698188)_
- []()
