# 类的加载过程
<hr />

## 类的五个过程
- 加载
- 验证
- 准备
- 解析
- 初始化
### 类的加载过程
![类的加载过程](https://img-blog.csdnimg.cn/img_convert/b2753b8c78fcded07a9d3b355533bb52.png)
### 类的生命周期
![类的生命周](https://pic1.zhimg.com/80/v2-f3947f904bafb2fc76669dbe7cd6113c_1440w.webp)

### 需要初始化的情况
《Java虚拟机规范》 严格规定了有且只有六种情况必须立即对类进行`“初始化”`：
1. 遇到`new`、`getstatic`、`putstatic`或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
2. 使用`java.lang.reflect`包的方法对类型进行`反射调用`的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其`父类`还没有进行过初始化，则需要先触发其`父类`的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用`JDK 7`新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
这六种场景中的行为称为对一个类型进行主动引用。

接下来我们来详细学习Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化。

### 加载 Loading （加载指的是把class字节码文件从各个来源通过类加载器装载入内存中）
所谓`加载`，简而言之就是将 `Java` 类的字节码文件加载到机器内存中，（一个Java文件从编码完成到最终执行，一般主要包括两个过程：`编译`和`运行`，其中编译就是把我们写好的java文件，通过`javac`命令编译成字节码，也就是我们常说的`.class`文件，然后运行则是把编译声称的`.class`文件交给`Java虚拟机(JVM)`执行。而我们所说的类加载过程即是指`JVM`虚拟机把`.class`文件中类信息加载进内存，并进行解析生成对应的`class`对象的过程。）并在内存中构建出`Java`类的原型——类模板对象。所谓类模板对象，其实就是`Java`类在`JVM`内存中的一个快照，`JVM`将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用
![Loading](https://pic1.zhimg.com/80/v2-c5257bba5081a767e610b04c70bacdb4_1440w.webp)

实际上`Java`的每个类被编译成`.class文件`的时候，`Java`虚拟机（jvm）会自动为这个类生成一个`类对象`，这个对象保存了这个类的`所有信息`（成员变量，方法，构造器等），以后这个类要想`实例化`（也就是创建类的实例或创建类的对象）那么都要以这个`class`对象为蓝图（或模版）来创建这个类的实例。

例子1:
`class<?> c=Class.forName(“com.pojo.User”)`; `c`就是`User`的类对象，而 `User u=new User()`;这个`u`就是以`c`为模版创建的，其实就相当于`u=c.newInstance()`; 这个在java的反射里面讲的比较清楚。

#### 反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射
例子2:
JVM在执行某段代码时，遇到了`class A`，然而此时内存中并没有`class A`的相关信息，于是`JVM`就会到相应的`class`文件中去寻找`class A`的类信息，并加载进内存中，这就是我们所说的类加载过程。由此可见，`JVM`不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且`只加载一次`。
在加载类时，Java 虚拟机必须完成以下3件事情：
1. 通过类的全名，获取类的`二进制数据流`
2. 解析类的二进制数据流为方法区内的数据结构(Java 类模型)
3. 创建 `java.lang.Class` 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口

#### 二进制流的获取方式：
对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。(只要所读取的字节码符合 JVM 规范即可)

1. 虚拟机可能通过文件系统读入一个 `Class` 后缀的文件(最常见)
2. 读入 `jar`、`zip` 等归档数据包，提取类文件
3. 事先存放在`数据库`中的类的二进制数据
4. 使用类似于 `HTTP` 之类的协议通过网络进行加载
5. 在运行时生成一段 `Class` 的二进制信息等
6. 在获取到类的二进制信息后，`Java` 虚拟机就会处理这些数据，并最终转为一个 `java.lang.Class` 的实例

#### 类模型与 `Class` 实例的位置
1. 类模型的位置
 - 加载的类在 `JVM` 中创建相应的类结构，类结构会存储在方法区(JDK 1.8之前：永久代；JDK 1.8之后：元空间)

2. Class 实例的位置
 - 类将 `.class` 文件加载至元空间后，会在堆中创建一个 `java.lang.Class` 对象，用来封装类位于方法区内的数据结构，该 `Class` 对象是在加载类的过程中创建的，每个类都对应有一个 `Class` 类型的对象
![Class](https://img-blog.csdnimg.cn/ed34463cee6f479b94f9b648ac2f40e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54iq5ZOH6LSh5bCY5ou-TWlyYWl0b3c=,size_14,color_FFFFFF,t_70,g_se,x_16) 

- 外部可以通过访问代表`Person`类的 `Class` 对象来获取 `Person`的类数据结构(看上图)
`Java`编译成字节码后，要运行需要通过`类加载器`，将类的`字节码`载入方法区中，内部采用`C++`的`instanceKlass`描述`Java`类，它的重要`field（域）`有：
- `_java_mirror` 即 `java` 的类镜像，例如对 `String` 来说，就是 `String.class`，作用是把 `class` 暴露给 `java` 使用;
- `_super` 即父类
- `_fields` 即成员变量
- `_methods` 即方法
- `_constants` 即常量池
- `_class_loader` 即类加载器
- `_vtable` 虚方法表
- `_itable` 接口方法表
如果这个类还有 `父类` 没有加载，先加载`父类`；
`加载`和`链接`可能是交替执行的
 - `instanceKlass` 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror是存储在堆中

## 链接 Linking
### 验证/校验 Verification （检查加载到Class的正确性和安全性）
- 验证是连接阶段的第一步，这一阶段的目的是确保`Class`文件的**字节流**中包含的信息符合`《Java虚拟机规范》`的全部约束要求。
- 验证阶段大致上会完成下面四个阶段的检验动作：`文件格式验证`、`元数据验证`、`字节码验证`和`符号引用验证`。
![Verification](https://pic4.zhimg.com/80/v2-ba9085befbef4b724d7dd89af08a7d4b_1440w.webp)
#### 文件格式验证
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。需要验证魔数、版本号、常量池常量类型是否支持、指向常量的索引值等等。
#### 元数据验证
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，包括类是否有父类、父类是否继承了final修饰的类、非抽象类是否实现了父类定义的方法、类是否与父类有矛盾等等。
#### 字节码验证
第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
#### 符号引用验证
最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。

符号引用验证主要验证类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

### 准备 Preparation （为类变量分配存储空间并设置类变量初始值）
- 准备阶段是给静态变量**分配内存**并**设置类变量初始值的阶段**。
- 在`JDK 7`及之前，这些变量的内存在方法区（永久代）中分配，在JDK 8及之后，静态变量则会随着Class对象一起存放在Java堆中。
![Preparation](https://pic2.zhimg.com/80/v2-749f3098bb203c518416eed35d65acd9_1440w.webp)
为 `static` 变量分配空间，设置默认值
1. `static` 变量在 `JDK 7` 之前存储于 `instanceKlass` 末尾，从 JDK 7 开始，存储于 `_java_mirror` 末尾
2. `static` 变量分配空间和赋值是两个步骤，分配空间在`准备阶段`完成，赋值在`初始化`阶段完成
3. 如果 `static` 变量是 `final` 的基本类型，以及`字符串常量`，那么`编译阶段`值就确定了，赋值在`准备阶段`完成
4. 如果 `static` 变量是 `final` 的`引用类型`，即 `new` 对象，那么赋值也会在`初始化`阶段完成
5. 
### 解析 Resolution （JVM将常量池内的符号饮用转换为直接饮用）
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。
- 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
![Resolution](https://pic1.zhimg.com/80/v2-d8242b078669fc649dce8698d953a338_1440w.webp)

- 符号引用与虚拟机实现的内存布局`无关`，直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般`不会相同`。
- 如果有了`直接引用`，那引用的目标必定已经在虚拟机的内存中存在。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行

### 初始化 Initialization （执行变量赋值和静态代码块）
类的初始化阶段是类加载过程的最后一个步骤，在这个阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。
- 准备阶段，变量被赋的是系统要求的零值，在初始化阶段，赋的是代码里编写的值。
- 初始化即调用`< cinit >()V`方法，虚拟机会保证这个类的`构造方法`的线程安全

#### 会导致`类初始化`的情况
- `main`方法所在的类，总会被首先初始化
- 首次访问这个类的`静态变量`或`静态方法`时
- 子类初始化，如果`父类`还未初始化，会引发
- 子类访问父类的`静态变量`，只会触发父类的初始化
- `Class.forName`
- `new` 会导致初始化
#### 不会导致 类初始化 的情况
- 访问类的 `static final` 静态变量（基本类型和字符型）不会触发初始化
- 类对象`.class`不会触发初始化
- 创建该类的数组不会触发初始化
- 类加载的`loadClass`方法
- `Class.forName`的参数`2`为`false`时
 
![Initialization](https://pic2.zhimg.com/80/v2-f367e5e6eb20ee9541a31b0ef324ef6d_1440w.webp)
## 参考
- [类加载的五个过程：加载、验证、准备、解析、初始化](https://blog.csdn.net/Strange_boy/article/details/125717606?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168238756316800197085188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168238756316800197085188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125717606-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187)
- [【JVM进阶之路】之：类加载过程](https://zhuanlan.zhihu.com/p/375698188)_
