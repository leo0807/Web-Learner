# 观察者优点
- 观察者模式可以实现**表示层**和**数据逻辑层**的分离，并降低观察目标和观察者之间**耦合度**；
- 观察者模式支持简单广播通信，自动通知所有已经订阅过的对象；
- 观察者模式符合“**开闭原则**”的要求；
- 观察目标和观察者之间的抽象耦合关系能够单独扩展以及重用。
# 缺点
当一个观察目标有多个直接或间接的观察者时，通知所有观察者的过程将会花费很多时间；
当观察目标和观察者之间存在循环依赖时，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
观察者模式缺少相应机制，让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
# 使用场景
在以下情况下可以使用观察者模式：

在一个抽象模型中，一个对象的行为依赖于另一个对象的状态。即当目标对象的状态发生改变时，会直接影响到观察者的行为；
一个对象需要通知其他对象发生反应，但不知道这些对象是谁。
需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。


# 发布订阅
# 优点
## 松耦合（Independence）
发布-订阅模式可以将众多需要通信的子系统(Subsystem)解耦，每个子系统独立管理。而且即使部分子系统取消订阅，也不会影响事件总线的整体管理。
发布-订阅模式中每个应用程序都可以专注于其核心功能，而事件总线负责将消息路由到每个订阅者手里。

## 高伸缩性（Scalability）
发布-订阅模式增加了系统的可伸缩性，提高了发布者的响应能力。原因是发布者(Publisher)可以快速地向输入通道发送一条消息，然后返回到其核心处理职责，而不必等待子系统处理完成。然后事件总线负责确保把消息传递到每个订阅者(Subscriber)手里。

## 高可靠性（Reliability）
发布-订阅模式提高了可靠性。异步的消息传递有助于应用程序在增加的负载下继续平稳运行，并且可以更有效地处理间歇性故障。

## 灵活性（Flexibility）
你不需要关心不同的组件是如何组合在一起的，只要他们共同遵守一份协议即可。
发布-订阅模式允许延迟处理或者按计划的处理。例如当系统负载大的时候，订阅者可以等到非高峰时间才接收消息，或者根据特定的计划处理消息。

# 缺点
在创建订阅者本身会消耗内存，但当订阅消息后，没有进行发布，而订阅者会一直保存在内存中，占用内存；
创建订阅者需要消耗一定的时间和内存。如果过度使用的话，反而使代码不好理解及代码不好维护。
# 使用场景
如果我们项目中很少使用到订阅者，或者与子系统实时交互较少，则不适合 发布-订阅模式 。
在以下情况下可以考虑使用此模式：

应用程序需要向大量消费者广播信息。例如微信订阅号就是一个消费者量庞大的广播平台。
应用程序需要与一个或多个独立开发的应用程序或服务通信，这些应用程序或服务可能使用不同的平台、编程语言和通信协议。
应用程序可以向消费者发送信息，而不需要消费者的实时响应。