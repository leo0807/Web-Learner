//https://www.jianshu.com/p/00c747510df5

// js变量回收规则：

// 在js中定义的全局变量是不会被销毁的，因为随时都可能会用到这个变量，所以不能被销毁。
// 具体引用关系的不会被销毁
// 如果一个对象不被引用，那么这个对象就会被回收；
// 如果两个对象互相引用，但是没有被第3个对象所引用，那么这两个互相引用的对象也会被回收。
// 通过下面两段代码进行对比分析：
function a() {
    var b = 10;
    return function () {
        b++;
        console.log(num);
    }
}
a()(); //11
a()(); //11

// 分析：
// 在函数a中返回了一个匿名函数，在这个匿名函数中我们num++了一下，然后在函数外面执行了这个匿名函数函数，现在num是11，然后又执行了一次这个函数，你们应该是12吧，为什么不是呢？
// 原因：
// js为了让没有必要的变量保存在内存中，（我们写的任何变量都是需要内存空间的）在不需要这个变量的时候它就会被销毁。所以每次执行一遍 a()() 则变量b就会被销毁。下次再执行，就会重新声明变量b，所以两次输出都是11。

function a() {
    var b = 0;
    return function () {
        b++;
        console.log(b);
    }
}
var d = a();
d();//1
d();//2

// 原因分析：

// 函数a 被 变量d 引用，更准确的说是 函数a 里面的 匿名函数 被变量d所引用。
// 因为变量d 保存的是函数a执行完成后的值，而函数a执行完，返回了那个匿名函数，所以变量d等于匿名函数。
// -匿名函数因为使用了 函数a 中的 变量b 并且还被 变量 d所引用，所以就形成了一个闭包。
// 只要这个变量d不等于null的话，那么那个变量b会一直保存到变量d中不会被销毁。
// 所以两次执行的结果不一样

// 作者：小本YuDL
// 链接：https://www.jianshu.com/p/00c747510df5
// 来源：简书
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。