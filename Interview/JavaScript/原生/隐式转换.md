# 文章源自[Here](https://blog.csdn.net/fe_dev/article/details/77369941)
JavaScript在比较的时候，会进行隐式转换，你如果对隐式转换不是特别熟悉，结果往往出乎你的意料。
我们来看看这行代码
```
(![]+[])[+!![]- -+!![]- -+!![]]+({}+[])[+!![]]+(![]+[])[+!![]- -+!![]- -+!![]]
```
这行代码的结果可能出乎你的意料，看结果
这里写图片描述
![image](https://github.com/leo0807/Web-Learner/blob/master/images/隐式转换.png)
结果居然是```sos```，这就是为什么会给文章这样一个题目了，这行代码看上去似乎是乱七八糟的，但是相信你看完这篇文章，一定能自己写出这样的代码来。

解释
相信我，这行代码是简单的，它并不复杂，我们先来分解一下这行代码
```
(![]+[])[+!![]- -+!![]- -+!![]]   //s
+  
({}+[])[+!![]]				      //o
+                
(![]+[])[+!![]- -+!![]- -+!![]]   //s
```
我们把这一行，分解成了3行了。

先看第一行
```(![]+[])[+!![]- -+!![]- -+!![]]```
这行还能分成两部分
```
(![]+[])		
[+!![]- -+!![]- -+!![]]
```
我们继续看这分开的两部分
```(![]+[])``` 看看这个是什么意思
友情提示：
```
[ ] 转为布尔值是 true
[ ] 转为字符串是 ""
```

```![ ] ```就是false
```(![]+[])```会转为这个样子 ```(false+"")``` 结果就是```"false"```,字符串类型的哦！

```[+!![]- -+!![]- -+!![]]```这个又是什么意思呢？
我们能看见``` +!![] ```这个东西是什么，居然出现了三次
```+!![]```，```!```的优先级最高，先算 ```!![ ]```，```!![ ]``` 是对 [ ]进行了布尔值的转换，最后结果就是true，最后在往前面来个+，就成了```+true``` 这样，进行隐式转换，把true转为数字，就是1，好了，```+!![] ```就是 1 的意思，我们用1来替换一下代码，看看变成了什么样子```[1- -1 - -1]```,我相信大家都能算出这么简单的正数 减 负数 减 负数 的结果来，所有最后的结果是[3]

好的，我们把第一行的这两个部分放在一起看看 "false"[3],这下明显了吧！字符串的第3个字符，这样就有s了

继续看第二行
```({}+[]])[+!![]]```
我们同样拆成两部分
```
({}+[]])
[+!![]]
```
### 第一部分 ({}+[])
( )里面的{}，不是语法上的花括号，不是语句块的意思，而是表示了一个空对象，这里相加的时候会调用对象的toString()方法，所以它会转为```"[object Object]"```，字符串类型的哦！
[ ],它同样也会调用toString()方法，所以[ ],会转为""，也就是一个空字符串。
这两个结果放在一起就是"[object Object]"+"" ,最后结果是"[object Object]"。

### 第二部分 [+!![]]
上面我们已经知道```+!![]``` 是 1 的意思，所以最后的结果就是```[1]```
好的，我们把第二行的这两个部分放在一起看看```"[object Object]"[1]```，这样我们就看的很清楚了，o也有了

最后的第三行，和第一行一模一样，好的我们用 + ,把这三行的结果拼接起来就是 ```“sos” ```了。

### 总结
最后用张图总结一下
![image](https://github.com/leo0807/Web-Learner/blob/master/images/隐式转换2.png)


- 使用null、布尔值和undefined这三类对象使用 + 进行操作，当有一边确定为数字的时候，这三类值会尝试用Number()进行转化，如果有一边类型确定为字符串的时候，直接就是进行字符串相加。
- 当关系比较有一边为数字的时候，会把其他数据类型调用Number()转化为数字后进行运算
- 当关系比较两边都为字符串的时候，会同时把字符串转化为数字进行比较，但是不是用Number()进行转化，而是按照字符串的unicode编码进行转化(string.charCodeAt,默认为字符的第一位)
- valueOf返回的数据类型决定是否调用toString，如果返回的类型是数字或者字符串(其实用基础数据类型更准确点)，toString方法就不执行了。 转化成字符串后再调用Number()转化成数字进行比较

当使用```!```逻辑非运算符进行转化的时候，会尝试把数据转化成布尔值
以下情况使用Boolean()转化将会得到false
0、-0、undefined、null、NaN、false、''(空字符串)、document.all

1. 规则 1：NaN 和其他任何类型比较永远返回 false（包括和他自己）。
  ```NaN == NaN // false```
2. 规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。
  ```
  true == 1 // true
  true == '2' // false, 先把 true 变成 1，而不是把 '2' 变成 true
  true == ['1'] // true, 先把 true 变成 1， ['1']拆箱成 '1', 再参考规则 3
  true == ['2'] // false, 同上
  undefined == false // false ，首先 false 变成 0，然后参考规则 4
  null == false // false，同上
  ```
3. 规则 3：String 和 Number 比较，先将 String 转换为 Number 类型。
  ```
  123 == '123' // true, '123' 会先变成 123
  '' == 0 // true, '' 会首先变成 0
  ```
4. 规则 4：null == undefined 比较结果是 true，除此之外，null、undefined 和其他任何结果的比较值都为 false。
  ```
  null == undefined // true
  null == '' // false
  null == 0 // false
  null == false // false
  undefined == '' // false
  undefined == 0 // false
  undefined == false // false
  ```
5. 规则 5：原始类型和引用类型做比较时，引用类型会依照 ToPrimitive 规则转换为原始类型。
  ⭐️ToPrimitive 规则，是引用类型向原始类型转变的规则，它遵循先 valueOf 后 toString 的模式期望得到一个原始类型。
  如果还是没法得到一个原始类型，就会抛出 TypeError。
  ```
  '[object Object]' == {} 
  // true, 对象和字符串比较，对象通过 toString 得到一个基本类型值
  '1,2,3' == [1, 2, 3] 
  // true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值
  ```

- ```[] == ![]```
```
    - 第一步，![] 会变成 false
    - 第二步，应用 规则2 ，题目变成： [] == 0
    - 第三步，应用 规则5 ，[]的valueOf是0，题目变成： 0 == 0
    - 所以， 答案是 true ！//
```
- ```[undefined] == false```
```
    - 第一步，应用 规则5 ，[undefined]通过toString变成 '',
      题目变成  '' == false
    - 第二步，应用 规则2 ，题目变成  '' == 0
    - 第三步，应用 规则3 ，题目变成  0 == 0
    - 所以， 答案是 true ！
    // 但是 if([undefined]) 又是个true！
```
