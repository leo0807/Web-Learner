JS是单线程的，它的多线程是通过异步的Event Loop进行实现的
EventLoop由三个部分组成，分别是调用栈***CallStack**，消息队列**Message Queue**和微任务队列组成**Microtask Queue**组成的
1. 函数被压入栈中执行
2. 回掉函数则会进入消息队列中成为消息，消息会在栈清空后运行
3. 异步操作如Promise和async则会被掉入微任务队列中，会在调用栈清空的时候立即执行，并且新加入的微任务也会一同被立即执行

# 为什么分为微任务和宏任务？
## 插队
在一个Event Loop中，微任务会在下一个事件循环之前执行调用完，并且其中将微任务中新注册的微任务一并调用执行完，然后开始下一次事件循环，所以如果有新的 Macrotask 就需要一直等待，等到上一个 Event loop 当中 Microtask 被清空为止。由此可见， 我们可以在下一次 Event loop 之前进行插队。

如果不区分 Microtask 和 Macrotask，那就无法在下一次 Event loop 之前进行插队，其中新注册的任务得等到下一个 Macrotask 完成之后才能进行，这中间可能你需要的状态就无法在下一个 Macrotask 中得到同步。状态的同步对于视图来说至关重要，这也就牵扯到了为什么 javascript 是单线程的原因所在。

作者：evan
链接：https://www.zhihu.com/question/316514618/answer/1311354630
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

每一个 task 会从头到尾将这个任务执行完毕，不会执行其它
浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
（`task->渲染->task->...`）
- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务

也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前
所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染
也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）
分别很么样的场景会形成 macrotask 和 microtask 呢？

- macrotask：主代码块，setTimeout，setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask）
- microtask：Promise，process.nextTick 等

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
5. 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）
