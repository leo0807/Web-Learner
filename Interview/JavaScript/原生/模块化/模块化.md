https://juejin.cn/post/6844903939763077127#heading-10

| 名称  | CommonJS | AMD | CMD |ES6 |
| ------------- | ------------- |------------- | ------------- |------------- |
| API  | module.exports + require | define+require  | define+require |import export |
| 执行环境 | 服务端 | 客户端 | 客户端 | 客户端+服务端 |
| 执行方式  | 运行时加载 | 运行时加载  | 运行时加载 |编译时加载 |
| 同步/异步 | 同步 | 异步 | 需要时加载 |  |


# ES6模块化import
ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。
```
//CommonJS模块
let {stat,exists,readFile} = require('fs')

//等同于
let _fs = require('fs');
let stat = _fs.stsat, exists = _fs.exists, readFile = _fs.readFile;
```
复制代码上面代码的实质是整体加载fs模块(即加载fs的所有方法)，生成一个对象( )，然后再从这个对象上面读取3个方法。这种加载称为"运行时加载" ，因为只有运行时才能得到这个对象，导致完全没办法在编译时做静态优化。
ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。
```
//ES6模块
import {stat, exists, readFile} from 'fs';
```
复制代码上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为编译时加载 ，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。
在 ES6 模块中，无论你是否加入“use strict;”语句，默认情况下模块都是在严格模式下运行。

# CommonJS的特点：

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。
Node内部提供一个Module构建函数。所有模块都是Module的实例。
