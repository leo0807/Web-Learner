# 如何解决JavaScript中0.1+0.2不等于0.3

### console.log(0.1+0.2===0.3); //true or false?
在正常的数学逻辑思维中，0.1+0.2=0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2!==0.3，这是为什么呢？这个问题也会偶尔被用来当做面试题来考查面试者对JavaScript的数值的理解程度

浮点数在计算机中的表示是用阶码与尾数结合的形式。

0.75 的二进制表现模式就是```(1 + 1 * 2 ^ -1) * 2 ^ -1```，为了看得直观，这里表达式中的2没有用10来表示
二进制中2 ^ -1表示的其实是十进制中的0.5。想想十进制中幂次方多1代表数值10倍，那么二进制中幂次方多1代表数值2倍。
0.75 在二进制中是可以妥善表现出来的。
``
var num = 0.75;
num.toString(2);
// 0.11
```
而0.1在二进制中却是一个表现不出来的无限不循环数，所以只能取一个近似数。

而计算机精度有限，所能表现的值而非真正的0.1，0.2，所以自然相加时有偏差

在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false

每一个变量的存储空间是有限的。
整数通常是2个字节， 浮点数最大8个字节。那么它能表示的数字大小也是有限的。
尤其是对于浮点数来讲，小数点后的位数是可以无穷尽的。当表示一个小数时，
计算机会由于空间有限而对二进制的数据进行部分的舍弃。
这样就导致了误差的出现。

那么应该怎样来解决0.1+0.2等于0.3呢? 最好的方法是设置一个误差范围值，通常称为”机器精度“，而对于 JavaScript 来说，这个值通常是**2^-52**,而在 ES6 中，已经为我们提供了这样一个属性：**Number.EPSILON**，而这个值正等于2^-52。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true

### 解决方案一：
```
function numbersEqual(a,b){
return Math.abs(a-b)<Number.EPSILON;
}
var a=0.1+0.2， b=0.3;
console.log(numbersEqual(a,b)); //true
```
### 解决方案二：
```
var x = 0.1;
var y = 0.2;
//可以先将浮点数，变成整数，再做除法。
(x10 + y10)/10
```