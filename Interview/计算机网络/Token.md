来源： https://segmentfault.com/a/1190000017831088

# 什么是Token
1. token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据
2. Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码

# token组成
1. uid: 用户唯一身份标识
2. time: 当前时间的时间戳
3. sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接
4. 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库

# Token使用举例
客户端使用用户名密码登录。
- 服务端收到请求，去验证用户名与密码。验证成功后，服务端会签发一个 Token，把这个 Token 发送给客户端。
- 客户端将收到的 Token 存储起来。（token 在客户端一般存放于 localStorage，cookie，或 sessionStorage 中。**在服务器一般存于数据库中**）
- 客户端每次需要登录验证的请求都需要带着 Token 发送给服务器端。
- 服务器端采用 filter 过滤器校验。校验成功则返回请求数据，校验失败则返回错误码

# token 可以抵抗 csrf，cookie+session 不行
假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对 csrf 攻击进行防护。攻击者就可以在网页放一个表单，该表单提交 src 为http://www.bank.com/api/transfer，body为count=1000&to=Tom。

倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在 post 请求的瞬间，cookie 会被浏览器自动添加到请求头中。

但 token 不同，token 是开发者为了防范 csrf 而特别设计的令牌，浏览器不会自动添加到 headers 里，攻击者也无法访问用户的 token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。


# 有效期设置
Refresh Token，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 Token 的过期时间，一旦 Token 过期，就反馈给前端，前端使用 Refresh Token 申请一个全新 Token 继续使用。这种方案中，服务端只需要在客户端请求更新 Token 的时候对 Refresh Token 的有效性进行一次检查

# Token解决的问题
- Token 完全由应用管理，所以它可以避开同源策略
- Token 可以避免 CSRF 攻击
- Token 可以是无状态的，可以在多个服务间共享

# 无状态Token
1. 服务端能确认是自己签发的 Token，而且其信息未被改动过，那就可以认为 Token 有效
2. 签发和验证都是服务器=》 对称加密算法=》 只需验证 不需要解密 =》 散列算法 HMAC

## 在使用无状态 Token 的时候，有两点需要注意：
- Refresh Token 有效时间较长，所以它应该在服务器端有状态，以增强安全性，确保用户注销时可控
- 应该考虑使用二次认证来增强敏感操作的安全性

## 分离认证服务
前端拿到一个有效的 Token，它就可以在任何同一体系的服务上认证通过——只要它们使用同样的密钥和算法来认证 Token 的有效性

当**业务服务器**已经不受信任的时候，多个业务服务器之间使用相同的 Token 对用户来说是不安全的。因为任何一个服务器拿到 Token 都可以仿冒用户去另一个服务器处理业务……悲剧随时可能发生。

为了防止这种情况发生，就需要在认证服务器产生 Token 的时候，把使用该 Token 的业务服务器的信息记录在 Token 中，这样当另一个业务服务器拿到这个 Token 的时候，发现它并不是自己应该验证的 Token，就可以直接拒绝。

# 解决Token劫持
- 在存储的时候把 token 进行对称加密存储，用时解开。
- 将请求 URL、时间戳、token 三者进行合并加盐签名，服务端校验有效性。
- HTTPS 对 URL 进行判断。

