**流量控制**发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易**丢包**，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。
对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:

- 拥塞窗口（Congestion Window，cwnd）
- 慢启动阈值（Slow Start Threshold，ssthresh）

涉及到的算法有这几个:

- 慢启动
- 拥塞避免
- 快速重传和快速恢复


# 拥塞窗口
**拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小**。
那么之前介绍了接收窗口的概念，两者有什么区别呢？

- 接收窗口(rwnd)是接收端给的限制
- 拥塞窗口(cwnd)是发送端的限制

限制谁呢？
限制的是发送窗口的大小。
有了这两个窗口，如何来计算发送窗口？
- **发送窗口大小 = min(rwnd, cwnd)**
取两者的较小值。而拥塞控制，就是来控制**cwnd**的变化。

# 慢启动
刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂**丢包**，造成雪崩式的网络灾难。
因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:

首先，三次握手，双方宣告自己的**接收窗口**大小
双方初始化自己的**拥塞窗口(cwnd)**大小
在开始传输的一段时间，发送端每收到一个**ACK**，拥塞窗口大小加 1，也就是说，每经过一个**RTT(Round-Trip Time，往返时延)**，cwnd **翻倍**。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。

难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做**慢启动阈值**，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！
在到达阈值后，如何来控制 cwnd 的大小呢？
这就是拥塞避免做的事情了。
# 拥塞避免
原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: **1 / cwnd**。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。
也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。
当然，**慢启动和拥塞避免是一起作用的，是一体的**。
# 快速重传和快速恢复
## 快速重传
在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是**重复发送之前的ACK**。
比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 **RTO（超时重传时间Retransmission TimeOut）** 的时间到了才重传。
这就是快速重传，它解决的是是否需要重传的问题。
## 选择性重传
那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？
当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。
在收到发送端的报文后，接收端回复一个 **ACK报文**，那么在这个报文首部的可选项中，就可以加上**SACK**这个属性，通过**left edge**和**right edge**告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。
## 快速恢复
当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。
在这个阶段，发送端如下改变：

- 拥塞阈值降低为 cwnd 的一半
- cwnd 的大小变为拥塞阈值
- cwnd 线性增加

以上就是 TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。



延迟确认
试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？
延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。
不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:

接收到了大于一个 frame 的报文，且需要调整窗口大小
TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）
发现了乱序包

两者一起使用会怎样？
前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。


作者：神三元
链接：https://juejin.cn/post/6844904070889603085
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。