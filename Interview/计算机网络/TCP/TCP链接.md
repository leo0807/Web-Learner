# 三次握手
三次握手的主要目的是确定客户端和服务器的发送数据能力和接收数据能力
![image](https://github.com/leo0807/Web-Learner/blob/master/images/三次握手.png)
- 最开始，客户端和服务端均处于**CLOSED**状态
- 服务器开启某个监听端口，此时服务器处于**LISTEN**状态
- 客户端**主动**发起链接，发送**SYN**，并且自己进入**SYN-SENT**的状态
- 服务端接收到**SYN**，自己变成**SYN-REVD**状态，返回**SYN**和**ACK**
- 之后客户端再发送**ACK**给服务端，自己变成了**ESTABLISHED**状态；服务端收到**ACK**之后，也变成了**ESTABLISHED**状态

另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:

凡是需要对端确认的，一定消耗TCP报文的序列号。

SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。

# 为什么不是两次？
根本原因: 无法确认客户端的接收能力。
分析如下:
如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。
看到问题的吧，这就带来了连接资源的浪费。

# 为什么不是4次
因为3次已经确立了链接关系。没有必要再次链接

# 建立链接的过程中能否携带数据
能，但是只能在第三次握手的时候携带

如果有人想要攻击服务器的话，那么他就可以在第一次握手的过程中携带大量的数据。这势必导致服务器花销大量时间和空间去处理这些请求，增加了服务器被攻击的风险。而三次握手时候，链接正常建立，客户端确认服务端的接收能力正常，可以开始链接。

# 为什么在三次握手的过程中要初始化序列号，为什么要使用随机序号，而不能使用固定的序号？
防止由于网络路由TCP报文段可能存在延迟抵达与排序混乱的问题，从而而导致某个连接的一方对它作错误的解释。

![image](https://github.com/leo0807/Web-Learner/blob/master/images/握手同时打开.png)
# 服务端和客户端同时打开链接
两者同时发送SYN，两者状态均变为SYN-SENT
两者同时收到SYN，状态均是SYN-REVD，接着回复对方SYN+ACK，最终两者状态一起变成ESTABLISHED