# QUIC
<a src="https://zhuanlan.zhihu.com/p/32553477">来源</a>
## QUIC概述
QUIC全称是quick udp internet connection，“快速UDP互联网连接”, 是由Goole提出的使用UDPUDP进行多路并发传输的协议。

$QUIC$相比$HTTP2+TCP+TLS$协议有如下的优势：
1. 减少了TCP三次握手和TLS握手时间；
2. 改进了拥塞控制；
3. 避免对头阻塞的多路复用；
4. 连接迁移；
5. 前向冗余纠错；
## 为什么需要QUIC
随着移动互联网快速发展以及物联网的逐步兴起，网络交互的场景越来越丰富，网络传输的内容也越来越庞大，用户对网络传输效率和 WEB 响应速度的要求也越来越高。
- 中间设备的僵化
- 依赖于操作系统的实现导致协议僵化
- 建立连接的握手延迟大
    1. TCP 三次握手导致的 TCP 连接建立的延迟。
    2. TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。
    3. 对于很多短连接场景，这样的握手延迟影响很大，且无法消除。
- 队头阻塞
- QUIC 核心特性连接建立延时低
    - 0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。
- 改进的拥塞控制
    1. TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。
    2. QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法
    - 可插拔
    - 单调递增的Packet Number
        - TCP为了保证可靠性，使用了基于字节序号的Seqeunce Number以及ACK来确认消息的有序到达。
        - QUIC使用Packet Number代替了TCP的Sequence Number，并且每个Packet Number都严格递增，即，如果Packer Numer N丢失了。重传的Packet Number 已经不是N，而是一个比N更大的数值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。
        <img src="https://pic2.zhimg.com/80/v2-8db4c3c378edaac0060b4238e3554091_1440w.jpg" />
        - 如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。

        - 如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。

        - 由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。
        <img src="https://pic2.zhimg.com/80/v2-086cc0ac3b95eb5bfe84a2d87bb2a645_1440w.jpg"/>
- 没有队头阻塞的多路复用
    - QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。
    - QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。
    - 这也就在很大程度上缓解甚至消除了队头阻塞的影响。
    - 多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示：
    <img src="https://pic2.zhimg.com/80/v2-2dd2a9fb8693489b9a0b24771c8a40a1_1440w.jpg" />
    - HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。

    - 不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞。
    - <img src="https://pic3.zhimg.com/80/v2-f1c2dcdb8f3cb56c260f408420cea502_1440w.jpg">
- 加密认证的报文
    - $TCP$协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。

    - 但是$QUIC$的$packet$可以说是武装到了牙齿。除了个别报文比如$PUBLIC_RESET$和$CHLO$，所有报文头部都是经过认证的，报文$Body$都是经过加密的。

    - 这样只要对$QUIC$报文任何修改，接收端都能够及时发现，有效地降低了安全风险。

    - 如下图所示，红色部分是$Stream Frame$的报文头部，有认证。绿色部分是报文内容，全部经过加密。

    - <img src="https://pic1.zhimg.com/80/v2-04f12b295aae3fb44b490b852e5c1e44_1440w.jpg">


- 连接迁移
    - 一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。

    - 比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。

    - 又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。

    - 针对 TCP 的连接变化，MPTCP其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。

    - 所以从 TCP 连接的角度来讲，这个问题是无解的。

那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。

由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。
