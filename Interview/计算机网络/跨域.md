# 同源策略（Same origin Policy）：
  - 策略 策略主要是限制JS的能力
  1.无法读取非同源的 cookie、Storage、indexDB 的内容
  2.无法读取非同源的 DOM
  3.无法发送非同源的 AJAX，更加准确的说应该是发送了请求但被浏览器拦截了。

同源策略是指浏览器处于安全考虑，只允许与本域下的接口进行交互，
不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。
同源（本域）的概念：
同协议：都是为http或者https；
同域名：http://a.com/index.html 与 http://a.com/server.js 域名一致；
同端口：端口号一致（如都为8080）。

需要注意的是:对于当前页面来说页面存放的 JS 文件的域不重要，重要的是加载该 JS 页面所在什么域。

# 为什么会有同源策略
为了保护用户数据安全
1. 为了防止恶意网页可以获取其他网站的本地数据。
2. 为了防止恶意网站 iframe 其他网站的时候，获取数据。
3. 为了防止恶意网站在自已网站有访问其他网站的权利，以免通过 cookie 免登，拿到数据。

# 跨域的方式
1. 通过document.domain进行降域
比如在http://a.yilia.com 调用http://b.yilia.com
```
<script>
  document.domain = yilia.com；
</script>
//将两个域名都降域，此时就可以相互访问了
```
2. CORS
CORS 的概念：
CORS全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 ajax 跨域请求资源的方式，支持现代浏览器，IE支持10以上。
核心思想是通过自定HTTP头部，让浏览器与服务器沟通，从而决定请求响应是成功还是失败
实现方式：
当使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：**Access-Control-Allow-Origin**; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。

3. postMessage
postMesage主要是为了解决以下问题：
  1. 页面和其打开的新窗口的数据传递
  2. 多窗口之间消息传递
  3. 页面与嵌套的iframe消息传递
  4. 上面三个问题的跨域数据传递
postMessage是html5引入的API,postMessage()方法允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递.多用于窗口间数据通信,这也使它成为跨域通信的一种有效的解决方案.

postMessage的两个参数，
  1. **data**:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。

  2. **origin**：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为"*"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

多数高级浏览器，如Chrome，Safari和FireFox等均支持此功能。
假设有两个域名（主域域名不一致），其中iframe页面是允许访问调用，那么就可以用postMessage实现。
原理：
a域名发送请求postMessage，b域名**监听**到了message事件，就处理并返回数据
//b域名
```
<script>
window.frames[0].postMessage(this.value, '*');
//*号表示在任何域下都可以接收message
window.addEventListener('message', function(e){
  console.log(e.data);
})；
</script>
```
例子

http://test.com/index.html

```
<div style="width:200px; float:left; margin-right:200px;border:solid 1px #333;">
        <div id="color">Frame Color</div>
    </div>
    <div>
        <iframe id="child" src="http://lsLib.com/lsLib.html"></iframe>
    </div>
```
 

我们可以在http://test.com/index.html通过postMessage()方法向跨域的iframe页面http://lsLib.com/lsLib.html传递消息
```
window.onload=function(){
            window.frames[0].postMessage('getcolor','http://lslib.com');
        }
```
接收消息
test.com上面的页面向lslib.com发送了消息，那么在lslib.com页面上如何接收消息呢，监听window的message事件就可以

http://lslib.com/lslib.html
```
window.addEventListener('message',function(e){
                if(e.source!=window.parent) return;
                var color=container.style.backgroundColor;
                window.parent.postMessage(color,'*');
  },false);
```
这样我们就可以接收任何窗口传递来的消息了，为了安全起见，我们利用这时候的**MessageEvent**对象判断了一下消息源

4. 通过location.hash跨域
因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。

5. JSONP(JSON with padding)原理：
利用html里面script标签可以加载其他域下的js这一特性，使用script src的形式来获取其他域下的数据，但是因为是通过标签引入的，所以会将请求到的JSON格式的数据作为js去运行处理，显然这样运行是不行的，所以就需要提前将返回的数据包装一下，封装成函数进行运行处理，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。（JSONP 需要对应接口的后端的配合才能实现）

实例：
```
<script>
function showData(ret){
console.log(ret);
}
</script>
<script src="http://api.jirengu.com/weather.php?callback=showData"></script>
```
当script src请求到达后端后，后端会去解析callback这个参数获取到字符串showData，在发送数据后端返回数据用showData封装一下，即 showData({"json数据"}) ，前端script标签在加载数据后会把json数据作为showData的参数，调用函数运行。
- 优点 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。
- 缺点 它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
- **CORS和JSONP**的比较
    - JSONP只能实现GET请求，而CORS支持所有类型的HTTPHTTP请求
    - 使用CORS，开发者可以使用XMLHHttpRequest发起请求获得数据，比起JSONP有更好的错误处理
    - 旧版本浏览器大多支持JSONP而不支持CORS，而新版本浏览器则支持CORS