1. memo 与 PureComponent一样，不同是memo服务于函数组件
- 原理：React.memo会对props进行浅比较
- React 函数组件的 useState，其 setState 会自动做浅比较，也就是如果你在上面例子中调用了 setState(0) ，函数组件会忽略这次更新，并不会执行 render 的。
2. useCallBack/useMemo
- 如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。

- 拓展知识 useCallback 是```useMemo```的返回值为函数」时的特殊情况，是 React 提供的便捷方式。在 React Server Hooks 代码 中，```useCallback``` 就是基于 ```useMemo``` 实现的。尽管 ```React Client Hooks``` 没有使用同一份代码，但 ```useCallback``` 的代码逻辑和 ```useMemo``` 的代码逻辑仍是一样的。

- React 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 How to memoize calculations
- 缓存优化往往是最简单有效的优化方式，但 useMemo 缓存加速只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 memoizee

- useMemo并不一定能够每次都缓存数据，React可能会选择忘记之前的一些被缓存的value并在下次渲染的时候重新计算；如，为offscreen的组件释放内存

3. shouldComponentUpdate / PureComponent
```
  shouldComponentUpdate(nextProps, nextState) {
      if(nextState.age != this.state.age || netState.name = this.state.name) {
        return true;
      }
      return false;
  }
```
4. 懒加载组件
```
import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    
    var ComponentToLazyLoad = null;
    
    if(this.props.name == "Mayank") { 
      ComponentToLazyLoad = lazy(() => import("./mayankComponent"));
    } else if(this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() => import("./anshulComponent"));
    }
    return (
        <div>
            <h1>This is the Base User: {this.state.name}</h1>
            <Suspense fallback={<div>Loading...</div>}>
                <ComponentToLazyLoad />
            </Suspense>
        </div>
    )
  }
}
```
5. 不要使用内联函数定义
- 如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例。
- 当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。
- 因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。
6. 批量更新，减少render次数
如```setState```的“异步”批量更新
7. 懒加载
懒加载的实现是通过 ```Webpack``` 的动态导入和 ```React.lazy```，```React.Suspense``` 方法
8. 懒渲染
懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 ```Modal/Drawer``` 等，当 ```visible``` 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。懒渲染的使用场景有：

- 1. 页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。
- 2. 需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。
- 3. 懒渲染的实现中判断组件是否出现在可视区域内是通过 ```react-visibility-observer``` 进行监听。
```
import { useState, useEffect } from 'react'
import VisibilityObserver, {
  useVisibilityObserver
} from 'react-visibility-observer'

const VisibilityObserverChildren = ({ callback, children }) => {
  const { isVisible } = useVisibilityObserver()
  useEffect(
    () => {
      callback(isVisible)
    },
    [callback, isVisible]
  )

  return <>{children}</>
}

export const LazyRender = () => {
  const [isRendered, setIsRendered] = useState(false)

  if (!isRendered) {
    return (
      <VisibilityObserver rootMargin={'0px 0px 0px 0px'}>
        <VisibilityObserverChildren
          callback={isVisible => {
            if (isVisible) {
              setIsRendered(true)
            }
          }}
        >
          <span />
        </VisibilityObserverChildren>
      </VisibilityObserver>
    )
  }

  console.log('滚动到可视区域才渲染')
  return <div>我是 LazyRender 组件</div>
}

export default LazyRender
```
9. 虚拟列表
如 react-window，react-virtualized
```
import {FixedSizeList as List} from 'react-window'
const Row = ({index, style}) => <div style={style}>Row {index}</div>

const Example = () => (
  <List
    height={150}
    itemCount={1000}
    itemSize={35}
    width={300}
  >
  {Row}
  </List>
)
```
10. 动画库直接修改 DOM 属性，跳过组件 Render 阶段
这个优化在业务中应该用不上，但还是非常值得学习的，将来可以应用到组件库中。

参考 ```react-spring``` 的动画实现，当一个动画启动后，每次动画属性改变不会引起组件重新 Render ，而是直接修改了 dom 上相关属性值。
```
import React, { useState } from 'react'
import { useSpring, animated as a } from 'react-spring'
import './styles.css'

let renderCnt = 0
export function Card() {
  const [flipped, set] = useState(false)
  const { transform, opacity } = useSpring({
    opacity: flipped ? 1 : 0,
    transform: `perspective(600px) rotateX(${flipped ? 180 : 0}deg)`,
    config: { mass: 5, tension: 500, friction: 80 }
  })

  // 尽管 opacity 和 transform 的值在动画期间一直变化
  // 但是并没有组件的重新 Render
  return (
    <div onClick={() => set(state => !state)}>
      <div style={{ position: 'fixed', top: 10, left: 10 }}>
        Render 次数：
        {++renderCnt}
      </div>
      <a.div
        class="c back"
        style={{ opacity: opacity.interpolate(o => 1 - o), transform }}
      />
      <a.div
        class="c front"
        style={{
          opacity,
          transform: transform.interpolate(t => `${t} rotateX(180deg)`)
        }}
      />
    </div>
  )
}

export default Card

```
11. 跳过回调函数改变触发的 Render 过程
React 组件的 Props 可以分为两类。
a) 一类是在对组件 Render 有影响的属性，如：页面数据、getPopupContainer 和 renderProps 函数。
b) 另一类是组件 Render 后的回调函数，如：onClick、onVisibleChange。
b) 类属性并不参与到组件的 Render 过程，因为可以对 b) 类属性进行优化。
当 b)类属性发生改变时，不触发组件的重新 Render ，而是在回调触发时调用最新的回调函数。
Dan Abramov 在 A Complete Guide to useEffect 文章中认为，每次 Render 都有自己的事件回调是一件很酷的特性。
但该特性要求每次回调函数改变就触发组件的重新 Render ，这在性能优化过程中是可以取舍的。
例子参考：跳过回调函数改变触发的 Render 过程。
以下代码比较难以理解，可通过调试该例子，帮助理解消化。
```
import { Children, cloneElement, memo, useEffect, useRef } from 'react'
import { useDeepCompareMemo } from 'use-deep-compare'
import omit from 'lodash.omit'

let renderCnt = 0

export function SkipNotRenderProps({ children, skips }) {
  if (!skips) {
    // 默认跳过所有回调函数
    skips = prop => prop.startsWith('on')
  }

  const child = Children.only(children)
  const childProps = child.props
  const propsRef = useRef({})
  const nextSkippedPropsRef = useRef({})
  Object.keys(childProps)
    .filter(it => skips(it))
    .forEach(key => {
      // 代理函数只会生成一次，其值始终不变
      nextSkippedPropsRef.current[key] =
        nextSkippedPropsRef.current[key] ||
        function skipNonRenderPropsProxy(...args) {
          propsRef.current[key].apply(this, args)
        }
    })

  useEffect(() => {
    propsRef.current = childProps
  })

  // 这里使用 useMemo 优化技巧
  // 除去回调函数，其他属性改变生成新的 React.Element
  return useDeepCompareMemo(
    () => {
      return cloneElement(child, {
        ...child.props,
        ...nextSkippedPropsRef.current
      })
    },
    [omit(childProps, Object.keys(nextSkippedPropsRef.current))]
  )
}

// SkipNotRenderPropsComp 组件内容和 Normal 内容一样
export function SkipNotRenderPropsComp({ onClick }) {
  return (
    <div className="case">
      <div className="caseHeader">
        跳过『与 Render 无关的 Props』改变触发的重新 Render
      </div>
      Render 次数为：
      {++renderCnt}
      <div>
        <button onClick={onClick} style={{ color: 'blue' }}>
          点我回调，回调弹出值为 1000（优化成功）
        </button>
      </div>
    </div>
  )
}

export default SkipNotRenderPropsComp
```
12. 按优先级更新，及时响应用户
优先级更新是批量更新的逆向操作，其思想是：优先响应用户行为，再完成耗时操作。
常见的场景是：页面弹出一个 Modal，当用户点击 Modal 中的确定按钮后，代码将执行两个操作。a) 关闭 Modal。b) 页面处理 Modal 传回的数据并展示给用户。当 b) 操作需要执行 500ms 时，用户会明显感觉到从点击按钮到 Modal 被关闭之间的延迟。
例子参考：CodeSandbox 在线 Demo。在该例子中，用户添加一个整数后，页面要隐藏输入框，并将新添加的整数加入到整数列表，将列表排序后再展示。以下为一般的实现方式，将 slowHandle 函数作为用户点击按钮的回调函数。
```
const slowHandle = () => {
  setShowInput(false)
  setNumbers([...numbers, +inputValue].sort((a, b) => a - b))
}
```
slowHandle() 执行过程耗时长，用户点击按钮后会明显感觉到页面卡顿。如果让页面优先隐藏输入框，用户便能立刻感知到页面更新，不会有卡顿感。 实现优先级更新的要点是将耗时任务移动到下一个宏任务中执行，优先响应用户行为。 例如在该例中，将 setNumbers 移动到 setTimeout 的回调中，用户点击按钮后便能立即看到输入框被隐藏，不会感知到页面卡顿。优化后的代码如下。
```
const fastHandle = () => {
  // 优先响应用户行为
  setShowInput(false)
  // 将耗时任务移动到下一个宏任务执行
  setTimeout(() => {
    setNumbers([...numbers, +inputValue].sort((a, b) => a - b))
  })
}
```
13. 状态下放，缩小状态影响范围
如果一个状态只在某部分子树中使用，那么可以将这部分子树提取为组件，并将该状态移动到该组件内部。如下面的代码所示，虽然状态 ```color``` 只在 ```<input />``` 和 ```<p />``` 中使用，但 color 改变会引起 ```<ExpensiveTree />``` 重新 ```Render```。
```
import { useState } from "react"

export default function App() {
  let [color, setColor] = useState("red")
  return (
    <div>
      <input value={color} onChange={e => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
      <ExpensiveTree />
    </div>
  )
}

function ExpensiveTree() {
  let now = performance.now()
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>
}
```
通过将 color 状态、```<input />``` 和 ```<p />``` 提取到组件 ```Form``` 中，结果如下。
```
export default function App() {
  return (
    <>
      <Form />
      <ExpensiveTree />
    </>
  )
}

function Form() {
  let [color, setColor] = useState("red")
  return (
    <>
      <input value={color} onChange={e => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
    </>
  )
}
```
这样调整之后，```color``` 改变就不会引起组件 ```App``` 和 ```ExpensiveTree``` 重新 ```Render``` 了。
如果对上面的场景进行扩展，在组件 ```App``` 的顶层和子树中都使用了状态 ```color``` ，但 ```<ExpensiveTree />``` 仍然不关心它，如下所示。
```
import { useState } from "react"

export default function App() {
  let [color, setColor] = useState("red")
  return (
    <div style={{ color }}>
      <input value={color} onChange={e => setColor(e.target.value)} />
      <ExpensiveTree />
      <p style={{ color }}>Hello, world!</p>
    </div>
  )
}
```
在这种场景中，我们仍然将 color 状态抽取到新组件中，并提供一个插槽来组合 ```<ExpensiveTree />```，如下所示。
```
import { useState } from "react"

export default function App() {
  return <ColorContainer expensiveTreeNode={<ExpensiveTree />}></ColorContainer>
}

function ColorContainer({ expensiveTreeNode }) {
  let [color, setColor] = useState("red")
  return (
    <div style={{ color }}>
      <input value={color} onChange={e => setColor(e.target.value)} />
      {expensiveTreeNode}
      <p style={{ color }}>Hello, world!</p>
    </div>
  )
}
```


作者：MoonBall
链接：https://juejin.cn/post/6935584878071119885
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
