# 组件的生命周期
React 为组件的不同生命阶段，提供了近十个钩子方法。

- componentWillMount()：组件加载前调用
- componentDidMount()：组件加载后调用
- componentWillUpdate(): 组件更新前调用
- componentDidUpdate(): 组件更新后调用
- componentWillUnmount()：组件卸载前调用
- componentWillReceiveProps()：组件接受新的参数时调用

# React 条件渲染方式
1. 组件变量
2. HOC
3. IF-ElSE
4. 子组件
5. 三元运算符
6. &&
7. IIFE
8. 函数

# setState 原理
https://www.jianshu.com/p/e09cbecca1d1

# React v16.4+ 的生命周期
https://www.jianshu.com/p/514fe21b9914

# 变更缘由
原来（React v16.0 前）的生命周期在 React v16 推出的 Fiber 之后就不合适了，因为如果要开启 async rendering，在 render 函数之前的所有函数，都有可能被执行多次
在Render之前执行执行的生命周期函数
- componentWillMount
- componentWillReceiveProps
- shouldComponentUpdate
- componentWillUpdate
如果开发者开了 async rendering，而且又在以上这些 render 前执行的生命周期方法做 AJAX 请求的话，那 AJAX 将被无谓地多次调用。。。明显不是我们期望的结果。而且在 componentWillMount 里发起 AJAX，不管多快得到结果也赶不上首次 render，而且 componentWillMount 在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的 IO 操作放在 componentDidMount 里更合适

**https://juejin.cn/post/6844903588720820231**  



除了 shouldComponentUpdate，其他在 render 函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被 getDerivedStateFromProps 替代。
## componentWillReceiveProps的问题
- 如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。
- 一般使用场景：如果组件自身的某个 ```state``` 跟父组件传入的 ```props``` 密切相关的话，那么可以在该方法中判断前后两个 props 是否相同，如果不同就根据 ```props``` 来更新组件自身的 ```state```。
类似的业务需求比如：一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。
- 但是此方法会破坏state数据的单一数据源，导致组建状态变得不可预测，另一方面也会增加组件的重绘次数。


## getDerivedStateFromProps
getDerivedStateFromProps 本来（React v16.3 中）是只在**创建**和**更新**（由父组件引发部分）中调用。如果不是由父组件引发，那么 getDerivedStateFromProps 也不会被调用，如自身 setState 引发或者 forceUpdate 引发。

### React v16.4 后的 getDerivedStateFromProps
static getDerivedStateFromProps(props, state) 在组件创建时和更新时的 render 方法之前调用，并且在初始挂载以及后续更新的时候都会被调用。它应该返回一个**对象**来更新```state```，或者返回 **null** 来不更新任何内容。

1. getDerivedStateFromProps 前面要加上 static 保留字，声明为静态方法，不然会被 react 忽略掉
2. getDerivedStateFromProps 是一个静态方法，静态方法不依赖于组件实例而存在，所以方法里面的 this 为 undefined
3. 因为无法拿到组件实例的this，这也导致了无法在此方法内部实现```this.fetch()```，或不合理的```this.setState()```操作导致可能的死循环或者其他副作用。 这种做法尽可能的保持了生命周期行为的可控可预测，根源上帮助避免不合理的编程方式，即一个API要保持单一性，做一件事的理念。
作者：aermin
链接：https://www.jianshu.com/p/514fe21b9914
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## componentWillMount
1. 应该避免在此方法中引入任何副作用或事件订阅，而是选用 ```componentDidMount()```。
2. - 在 React 初学者刚接触的时候，可能有这样一个疑问：一般都是数据请求放在 ```componentDidMount``` 里面，但放在 ```componentWillMount``` 不是会更快获取数据吗？
 - 因为理解是 ```componentWillMount``` 在 render 之前执行，早一点执行就早拿到请求结果；但是其实不管你请求多快，都赶不上首次 render，页面首次渲染依旧处于没有获取异步数据的状态。
 - 还有一个原因，```componentWillMount``` 是服务端渲染唯一会调用的生命周期函数，如果你在此方法中请求数据，那么服务端渲染的时候，在服务端和客户端都会分别请求两次相同的数据，这显然也不是我们想看到的结果。
 - 特别是有了 React Fiber，更有机会被调用多次，故请求不应该放在 componentWillMount 中。
2. 还有一个错误的使用是在 ```componentWillMount``` 中订阅事件，并在 componentWillUnmount 中取消掉相应的事件订阅。事实上只有调用 ```componentDidMount``` 后，React 才能保证稍后调用 componentWillUnmount 进行清理。而且服务端渲染时不会调用 componentWillUnmount，可能导致内存泄露。
还有人会将事件监听器（或订阅）添加到 componentWillMount 中，但这可能导致服务器渲染（永远不会调用 componentWillUnmount）和异步渲染（在渲染完成之前可能被中断，导致不调用 componentWillUnmount）的内存泄漏。
对于该函数，一般情况，如果项目有使用，则是通常把现有 componentWillMount 中的代码迁移至 componentDidMount 即可



## componentWillUpdate
- 当组建收到新的props或state时候，会在渲染之前调用componentWillUpdate（）。使用此生命周期在更新发生之前准备更新的机会。初始渲染不会调用此方法。在此生命周期不能调用this.setState()或其他任何会对React组件更新的操作。

- 此生命周期也发生在render之前，也存在一次更新多次调用的可能。
- 该方法的常见用法是在组建更新前，读取某个DOM元素的状态，并在```componentDidUpdate```中进行相应的处理。但是因为React16后，React增加了```suspense```，异步渲染机制等等，render过程可以被分割多次完成，还可以暂停甚至回溯，这导致```componentWillUpdate```和```componentDidUpdate```执行前后可能会间隔很长时间，这导致DOM元素状态是不安全的，因为这个时候的值很有可能已经失效了。而且足够使用户进行交互操作更改当前组建的状态，这样可能会导致难以追踪的BUG。

为了解决这个问题，产生了新的生命周期函数
```
getSnapShotBeforeUpdate(preProps, prevState)
```

## getSnapshotBeforeUpdate
getSnapshotBeforeUpdate() 被调用于 **render 之后，可以读取但无法使用 DOM 的时候**。它使组件可以在可能发生更改之前从 DOM 捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给 ```componentDidUpdate(prevProps, prevState, snapshot)```。

与 ```componentWillUpdate``` 不同，```getSnapshotBeforeUpdate``` 会在最终的 ```render``` 之前被调用，也就是说在 ```getSnapshotBeforeUpdate``` 中读取到的 ```DOM``` 元素状态是可以保证与 ```componentDidUpdate``` 中一致的。
虽然 ```getSnapshotBeforeUpdate``` 不是一个静态方法，但我们也应该尽量使用它去返回一个值。这个值会随后被传入到 ```componentDidUpdate``` 中，然后我们就可以在 ```componentDidUpdate``` 中去更新组件的状态，而不是在 ```getSnapshotBeforeUpdate``` 中直接更新组件状态。避免了 ```componentWillUpdate``` 和 ```componentDidUpdate``` 配合使用时将组件临时的状态数据存在组件实例上浪费内存，```getSnapshotBeforeUpdate``` 返回的数据在 ```componentDidUpdate``` 中用完即被销毁，效率更高。

如果项目中有用到 componentWillUpdate 的话，升级方案就是将现有的 componentWillUpdate 中的回调函数迁移至 componentDidUpdate。如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。



作者：aermin
链接：https://www.jianshu.com/p/514fe21b9914
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

