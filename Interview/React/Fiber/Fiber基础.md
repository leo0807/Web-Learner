## 帧的生命周期
每个帧包括样式计算， 布局和绘制
JavaScript执行JavaScript引擎和页面渲染引擎在同一个渲染线程， GUI渲染和JavaScript执行两者是互斥的
    1 处理输入事件（优先级较高）
        - 组设
    2 JS定时器
    3 开始帧
    4 requestAnimationFrame
    5 Layout 布局
    6 绘制 Paint
    - 空闲时段 Idle period
## window.requestIdleCallback(callback, {timeout: 1000})
这是一个全局属性
作用：
    我作为用户，告诉浏览器，我现在执行callback函数，但是它的优先级比较低。
    告诉浏览器，可以在空闲的时候执行callback函数
    但是如果到了超时时间（即1000ms后），即使没有空余时间，也要执行这个callback
## Fiber之前
### 协调

- React会递归比对Virtual DOM树，找出需要变动的节点，然后**同步更新**它们，这个过程React称为 Reconcilation（协调）
- 在**协调**期间，React会一直占用着浏览器资源，
    - 一则会导致用户触发的事件得不到响应；
    - 二则会导致掉帧，用户可能会感觉到卡顿
    <!-- 一个虚拟DOM 就是一个链表的节点，相当于最小单元 -->
    递归调用，执行栈会越来越深，整个过程不能中断
## 为什么需要Fiber
<!-- 这种调度方式叫做合作式调度，需要浏览器相信用户写的代码，
但是如果用户或者说客户端写代码的时候或者执行时间超过给的剩余时间，浏览器没有办法
所以一个虚拟DOM的更新超过16ms，也会卡的
 -->
 - JavaScript 引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待。
  在这样的机制下，如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿

## Fiber的核心架构
1. Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler
2. Reconciler 协调器 —— 负责找出变化的组件
3. Renderer 渲染器 —— 负责将变化的组件渲染到页面上


## Fiber
- Fiber是一个**执行单元**，每执行完一个执行单元，React会检查现在还剩多少时间，如果没有就会将控制权交出去
- 浏览器会先执行**高优先级任务**，如事件处理，Js执行，布局/绘制等
Fiber是把整个任务分成很多个小任务，每次执行一个任务，
执行完成后判断有没有剩余时间，如果有，继续执行下一个任务，如果没有则放弃执行

- React目前的做法是使用链表，每个VirtualDOM节点内部表示为一个Fiber
    - 每一个Fiber节点有三个指针，Child 大儿子，return 父亲， sibling兄弟节点
    ```
    this.return = null;
    this.child = null;
    this.sibling = null;
    ```
### Fiber 执行阶段
虚拟节点会转化为Fiber结构
- 每次渲染有两个阶段， **Reconciliation**（协调、Render阶段）和**Commit**（提交阶段）
- 协调阶段：可以认为是Diff阶段，这个阶段可以被中断，这个阶段会找出所有节点变更，
    例如节点新增，删除，属性变更等等，这些变更React称之为副作用
- 提交阶段：将上一个阶段计算出来的需要处理的副作用（Effects）一次性执行了，这个阶段必须同步执行，不能被打断
Render阶段会构建Fiber树，结果会构成一个 **Effect Lists**
遍历规则： - 下一个节点：先儿子， 后弟弟， 再叔叔
         - 自己所有节点完成后自己完成