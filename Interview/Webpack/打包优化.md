<!-- https://juejin.cn/post/6844904071736852487#heading-18 -->
1. 分析打包速度
speed-measure-webpack-plugin 可以用来测量webpack构建期间各个阶段花费的时间
```
// 分析打包时间
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
const smp = new SpeedMeasurePlugin();
// ...
module.exports = smp.wrap(prodWebpackConfig)

```

2. 优化解析时间，开启多进程打包
由于webpack是单线程模式的，所以当打包大量的文件需要较长的时间；
- thread-loader
    这个loader需要放置在其他loader之前，它之后的loader就会在一个单独的**worker pool**里面执行，一个worker 就是一个nodeJS 进程【node.js proces】，每个单独进程处理时间上限为600ms，各个进程的数据交换也会限制在这个时间内；
- HappyPack
    HappyPack 可以让 Webpack 同一时间处理多个任务，发挥多核 CPU 的能力，将任务分解给多个子进程去并发的执行，子进程处理完后，再把结果发送给主进程；
    **缺点**：只兼容部分主流的 loader；

3. 缓存 （缩短连续构建时间，增加初始构建时间）
- cache-loader
    需要在一些性能开销较大的 loader 之前添加此 loader，以将结果缓存到磁盘里，显著提升二次构建速度；
- HardSourceWebpackPlugin
    第一次构建将花费正常的时间；
    第二次构建将显着加快（大概提升90%的构建速度）；

4. 优化压碎时间
- webpack3
    webpack3 启动打包时加上 --optimize-minimize ，这样 Webpack 会自动为你注入一个带有默认配置的 UglifyJSPlugin；
- webpack4
    webpack4 默认内置使用 terser-webpack-plugin 插件压缩优化代码，而该插件使用 terser 来缩小 JavaScript；
- ParallelUglifyPlugin 可以开启多个子进程，每个子进程使用 UglifyJS 压缩代码，可以并行执行，能显著缩短压缩时间。


5. 优化文件搜索时间- 减少不必要的编译工作
- 优化**loader**配置
使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件
- 优化**resolve.module**配置
resolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块，resolve.modules 的默认值是 ['node_modules'] ，含义是先去当前目录下的 ['./node_modules'] 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推
- 优化**resolve.alias**配置
resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径，减少耗时的递归解析操作。
- 优化**resolve.extensions**配置
在导入语句没带文件后缀时，webpack 会根据 resolve.extension 自动带上后缀后去尝试询问文件是否存在，所以在配置 resolve.extensions 应尽可能注意以下几点：

resolve.extensions 列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。
频率出现**最高**的文件后缀要优先放在**最前面**，以做到尽快的退出寻找过程。
在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。

- 优化 resolve.mainFields 配置
有一些第三方模块会针对不同环境提供几分代码。 例如分别提供采用 ES5 和 ES6 的2份代码，这2份代码的位置写在 package.json 文件里，如下：
```
{
  "jsnext:main": "es/index.js",// 采用 ES6 语法的代码入口文件
  "main": "lib/index.js" // 采用 ES5 语法的代码入口文件
}
```
webpack 会根据 mainFields 的配置去决定优先采用那份代码，mainFields 默认如下：
```mainFields: ['browser', 'main']```
webpack 会按照数组里的顺序去 package.json 文件里寻找，只会使用找到的第一个。
假如你想优先采用 ES6 的那份代码，可以这样配置：
mainFields: ['jsnext:main', 'browser', 'main']

- 优化**module.noParse** 配置
module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。

# 其它 
1. 代码分离
在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 react，lodash，vue 我们希望能和自己的代码分离开，Webpack 社区有两种方案
- **CommonsChunkPlugin**
- **DLLPlugin**
对于 CommonsChunkPlugin，webpack 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而 DLLPlugin 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。Dll这个概念是借鉴了Windows系统的dll，一个dll包，就是一个纯纯的依赖库，它本身不能运行，是用来给你的app引用的。
- **optimization.splitChunks**
webpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。如果你的 mode 是**production**，那么 webpack4 就会自动开启 Code Splitting。

它内置的代码分割策略是这样的：

  - 新的 chunk 是否被共享或者是来自 node_modules 的模块
  - 新的 chunk 体积在压缩之前是否大于 30kb
  - 按需加载 chunk 的并发请求数量小于等于 5 个
  - 页面初始加载时的并发请求数量小于等于 3 个




2. 压缩
- **image-webpack-loader**
- **url-loader** 和 file-loader 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，url-loader 会将其转换为一个 base64 编码的 DataURL
- **html-webpack-plugin** 插件可以对HTML进行压缩

3. sideEffects
当某个模块的 package.json 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理, 如只使用lodash中的几个方法的时候不需要加载全部方法；

4. 分离代码文件
例如用**extract-text-webpack-plugin**分离公用的CSS文件

- webpack4 optimize.splitChunks
```
module.exports = {
  // ... webpack 配置

  optimization: {
    splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件
    },
  },
}
```

- 提取公共代码
```webpack3 CommonsChunkPlugin```
把多个页面依赖的公共代码提取到 common.js 中，此时 common.js 包含基础库的代码
```
const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');
module.exports = {
  // ...
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: "commons", // 公共使用的 chunk 的名称
      filename: "commons.js", // 公共 chunk 的生成文件名
      minChunks: 3, // 公共的部分必须被 3 个 chunk 共享
    }),
  ],
}
```
- 找出依赖的基础库，写一个 base.js 文件，再与 common.js 提取公共代码到 base 中，common.js 就剔除了基础库代码，而 base.js 保持不变
```
//base.js
import 'react';
import 'react-dom';
import './base.css';
//webpack.config.json
entry:{
    base: './base.js'
},
plugins:[
    new CommonsChunkPlugin({
        chunks:['base','common'],
        name:'base',
        //minChunks:2, 表示文件要被提取出来需要在指定的chunks中出现的最小次数，防止common.js中没有代码的情况
    })        
]
```
5. 使用输出分析工具
```--profile```记录webpack构建过程中的耗时信息，```> stats.json``` 是 ```UNIX / Linux``` 系统中的管道命令，含义是将内容通过管道输出到 stats.json 文件中
```webpack --profile --json > stats.json```
- 官方工具 Webpack Analyse
  - 打开该工具的官网```http://webpack.github.io/analyse/上传stats.json```，就可以得到分析结果
- webpack-bundle-analyzer
  - 在项目根目录执行 ```webpack-bundle-analyzer```，浏览器会自动打开结果分析页面。

6. 优化输出质量--提升代码运行时的效率
- 使用 Prepack 提前求值
  1. 原理：
    - Prepack 是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在便一阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在 Prepack 还不够成熟，用于线上环境还为时过早。
  2. 使用方法
    - ```
      const PrepackWebpackPlugin = require('prepack-webpack-plugin').default;
      module.exports = {
          plugins:[
              new PrepackWebpackPlugin()
          ]
      }
      ```
- 使用 Scope Hoisting
  1. 原理：
    - 译作“作用域提升”，是在 ```Webpack3``` 中推出的功能，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了 ```ES6``` 模块化的，否则 ```Webpack``` 会降级处理不采用 ```Scope Hoisting```。
  2. 使用方法
    - ```
      const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');
      //...
      plugins:[
          new ModuleConcatenationPlugin();
      ],
      resolve:{
        mainFields:['jsnext:main','browser','main']
      }
      ```
      ```webpack --display-optimization-bailout``` 输出日志中会提示哪个文件导致了降级处理


7. 使用CDN加速静态资源加载
```
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const {WebPlugin} = require('web-webpack-plugin');
//...
output:{
 filename: '[name]_[chunkhash:8].js',
 path: path.resolve(__dirname, 'dist'),
 publicPatch: '//js.cdn.com/id/', //指定存放JS文件的CDN地址
},
module:{
 rules:[{
     test: /\.css/,
     use: ExtractTextPlugin.extract({
         use: ['css-loader?minimize'],
         publicPatch: '//img.cdn.com/id/', //指定css文件中导入的图片等资源存放的cdn地址
     }),
 },{
    test: /\.png/,
    use: ['file-loader?name=[name]_[hash:8].[ext]'], //为输出的PNG文件名加上Hash值 
 }]
},
plugins:[
  new WebPlugin({
     template: './template.html',
     filename: 'index.html',
     stylePublicPath: '//css.cdn.com/id/', //指定存放CSS文件的CDN地址
  }),
 new ExtractTextPlugin({
     filename:`[name]_[contenthash:8].css`, //为输出的CSS文件加上Hash
 })
]
```

作者：superMaryyy
链接：https://juejin.cn/post/6844903651291447309
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：SHERlocked93
链接：https://juejin.cn/post/6844903951410659341
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：前端瓶子君
链接：https://juejin.cn/post/6844904071736852487
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。